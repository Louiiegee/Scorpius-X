"""
Autonomous Exploit API Routes
Endpoints for manual testing and control of the autonomous exploit engine
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/autonomous-exploit", tags=["Autonomous Exploit Engine"])

# Import autonomous exploit engine
try:
    from modules.autonomous_exploit_engine import autonomous_exploit_if_high_risk, AutonomousExploitEngine
    AUTONOMOUS_EXPLOIT_AVAILABLE = True
    logger.info("‚úÖ Autonomous Exploit Engine loaded in API routes")
except ImportError as e:
    AUTONOMOUS_EXPLOIT_AVAILABLE = False
    logger.warning(f"‚ö†Ô∏è Autonomous Exploit Engine not available: {e}")


class ExploitRequest(BaseModel):
    """Request model for autonomous exploit simulation"""
    contract_address: str = Field(..., description="Target contract address")
    attack_types: Optional[List[str]] = Field(None, description="Specific attack types to test")
    force_execution: bool = Field(False, description="Force execution even if risk score < 60")


class ExploitResponse(BaseModel):
    """Response model for exploit simulation"""
    contract_address: str
    exploit_executed: bool
    risk_score: int
    attacks_attempted: int
    successful_exploits: int
    critical_exploits: int
    execution_time: float
    timestamp: str
    status: str
    message: str


@router.get("/health")
async def get_autonomous_exploit_health():
    """Check if autonomous exploit engine is available and operational"""
    
    if not AUTONOMOUS_EXPLOIT_AVAILABLE:
        return JSONResponse(
            status_code=503,
            content={
                "status": "unavailable",
                "message": "Autonomous Exploit Engine not loaded",
                "available": False,
                "timestamp": datetime.now().isoformat()
            }
        )
    
    try:
        # Test engine initialization
        engine = AutonomousExploitEngine()
        
        return {
            "status": "operational",
            "message": "Autonomous Exploit Engine ready",
            "available": True,
            "attack_vectors_count": len(engine.attack_vectors),
            "exploit_suite_path": str(engine.exploit_suite_path),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return JSONResponse(
            status_code=500,
            content={
                "status": "error",
                "message": f"Engine initialization failed: {str(e)}",
                "available": False,
                "timestamp": datetime.now().isoformat()
            }
        )


@router.post("/execute", response_model=ExploitResponse)
async def execute_autonomous_exploit(
    request: ExploitRequest,
    background_tasks: BackgroundTasks
):
    """
    Manually trigger autonomous exploit simulation on a contract
    
    Args:
        request: Exploit configuration request
        
    Returns:
        ExploitResponse with simulation results
    """
    
    if not AUTONOMOUS_EXPLOIT_AVAILABLE:
        raise HTTPException(
            status_code=503,
            detail="Autonomous Exploit Engine not available"
        )
    
    logger.info(f"üéØ Manual autonomous exploit requested for {request.contract_address}")
    
    try:
        start_time = datetime.now()
        
        if request.force_execution:
            logger.info("üîì Force execution enabled - bypassing risk score check")
        
        # Execute autonomous exploit
        results = await autonomous_exploit_if_high_risk(request.contract_address)
        
        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()
        
        # Process results
        exploit_executed = results.get("exploit_executed", False)
        risk_score = results.get("risk_score", 0)
        attacks_attempted = results.get("attacks_attempted", 0)
        successful_exploits = results.get("successful_exploits", 0)
        critical_exploits = results.get("critical_exploits", 0)
        
        # Determine status
        if not exploit_executed and risk_score <= 60 and not request.force_execution:
            status = "skipped"
            message = f"Risk score {risk_score} below threshold (60). Use force_execution=true to override."
        elif critical_exploits > 0:
            status = "critical_risk"
            message = f"CRITICAL: {critical_exploits} critical exploits found!"
        elif successful_exploits > 0:
            status = "vulnerable"
            message = f"Contract is exploitable: {successful_exploits} successful attacks"
        elif exploit_executed:
            status = "secure"
            message = f"Contract appears secure: no successful exploits"
        else:
            status = "error"
            message = "Exploit execution failed"
        
        logger.info(f"‚úÖ Autonomous exploit completed: {status}")
        
        return ExploitResponse(
            contract_address=request.contract_address,
            exploit_executed=exploit_executed,
            risk_score=risk_score,
            attacks_attempted=attacks_attempted,
            successful_exploits=successful_exploits,
            critical_exploits=critical_exploits,
            execution_time=execution_time,
            timestamp=end_time.isoformat(),
            status=status,
            message=message
        )
        
    except Exception as e:
        logger.error(f"‚ùå Autonomous exploit failed: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Exploit execution failed: {str(e)}"
        )


@router.get("/attack-vectors")
async def get_available_attack_vectors():
    """Get list of available attack vectors in the autonomous exploit engine"""
    
    if not AUTONOMOUS_EXPLOIT_AVAILABLE:
        raise HTTPException(
            status_code=503,
            detail="Autonomous Exploit Engine not available"
        )
    
    try:
        engine = AutonomousExploitEngine()
        
        attack_vectors = []
        for name, config in engine.attack_vectors.items():
            attack_vectors.append({
                "name": name,
                "script": config["script"],
                "priority": config["priority"],
                "description": config["description"],
                "prerequisites": config["prerequisites"]
            })
        
        # Sort by priority (higher first)
        attack_vectors.sort(key=lambda x: x["priority"], reverse=True)
        
        return {
            "attack_vectors": attack_vectors,
            "total_vectors": len(attack_vectors),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Failed to get attack vectors: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to retrieve attack vectors: {str(e)}"
        )


@router.get("/recent-exploits")
async def get_recent_exploits(limit: int = 10):
    """Get recent autonomous exploit results (from reports directory)"""
    
    if not AUTONOMOUS_EXPLOIT_AVAILABLE:
        raise HTTPException(
            status_code=503,
            detail="Autonomous Exploit Engine not available"
        )
    
    try:
        from pathlib import Path
        import json
        
        reports_dir = Path("reports/autonomous_exploits")
        
        if not reports_dir.exists():
            return {
                "recent_exploits": [],
                "total": 0,
                "message": "No exploit reports found",
                "timestamp": datetime.now().isoformat()
            }
        
        # Get all JSON report files
        report_files = list(reports_dir.glob("autonomous_exploit_*.json"))
        
        # Sort by modification time (newest first)
        report_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        # Limit results
        report_files = report_files[:limit]
        
        recent_exploits = []
        for report_file in report_files:
            try:
                with open(report_file, 'r') as f:
                    report_data = json.load(f)
                
                # Extract summary info
                exploit_summary = {
                    "contract_address": report_data.get("contract_address"),
                    "analysis_timestamp": report_data.get("analysis_timestamp"),
                    "risk_score": report_data.get("risk_assessment", {}).get("risk_score", 0),
                    "threat_level": report_data.get("threat_level", "unknown"),
                    "total_attacks": report_data.get("exploit_simulations", {}).get("total_attacks", 0),
                    "successful_attacks": report_data.get("exploit_simulations", {}).get("successful_attacks", 0),
                    "critical_exploits": report_data.get("exploit_simulations", {}).get("critical_exploits", 0),
                    "report_file": report_file.name
                }
                
                recent_exploits.append(exploit_summary)
                
            except Exception as e:
                logger.warning(f"Failed to parse report {report_file}: {e}")
        
        return {
            "recent_exploits": recent_exploits,
            "total": len(recent_exploits),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Failed to get recent exploits: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to retrieve recent exploits: {str(e)}"
        )


@router.post("/simulate-attack")
async def simulate_specific_attack(
    contract_address: str,
    attack_type: str,
    background_tasks: BackgroundTasks
):
    """
    Simulate a specific attack type on a contract
    
    Args:
        contract_address: Target contract address
        attack_type: Specific attack vector to test
        
    Returns:
        Attack simulation results
    """
    
    if not AUTONOMOUS_EXPLOIT_AVAILABLE:
        raise HTTPException(
            status_code=503,
            detail="Autonomous Exploit Engine not available"
        )
    
    try:
        engine = AutonomousExploitEngine()
        
        # Check if attack type is valid
        if attack_type not in engine.attack_vectors:
            available_attacks = list(engine.attack_vectors.keys())
            raise HTTPException(
                status_code=400,
                detail=f"Unknown attack type '{attack_type}'. Available: {available_attacks}"
            )
        
        logger.info(f"üéØ Simulating {attack_type} attack on {contract_address}")
        
        start_time = datetime.now()
        
        from modules.autonomous_exploit_engine import ContractAnalysis
        mock_analysis = ContractAnalysis(
            contract_address=contract_address,
            risk_score=75,  # High enough to trigger exploit
            vulnerabilities=[],
            ai_analysis="Direct attack simulation",
            exploit_potential="Testing specific attack vector",
            recommended_attacks=[attack_type]
        )
        
        # Execute specific attack
        result = await engine._execute_attack_simulation(
            contract_address, 
            attack_type, 
            mock_analysis
        )
        
        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()
        
        return {
            "contract_address": contract_address,
            "attack_type": attack_type,
            "success": result.success,
            "impact_score": result.impact_score,
            "funds_extractable": result.funds_extractable,
            "description": result.description,
            "proof_of_concept": result.proof_of_concept,
            "execution_time": execution_time,
            "timestamp": result.timestamp.isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Attack simulation failed: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Attack simulation failed: {str(e)}"
        )
