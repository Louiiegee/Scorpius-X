#!/usr/bin/env python3
"""
Test Autonomous Exploit Integration
Demonstrates the complete AI scanner + autonomous exploit workflow
"""

import asyncio
import json
import logging
import time
from datetime import datetime
from typing import Dict, Any

# Configure logging for detailed output
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

async def test_autonomous_exploit_integration():
    """
    Test the complete autonomous exploit integration workflow:
    1. Start a vulnerability scan
    2. Monitor scan progress
    3. Check if autonomous exploit was triggered for high-risk contracts
    4. Review exploit results
    """
    
    print("üöÄ TESTING AUTONOMOUS EXPLOIT INTEGRATION")
    print("=" * 60)
    
    # Test contract addresses - mix of high and low risk
    test_contracts = [
        {
            "address": "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C",
            "name": "High-Risk Test Contract",
            "expected_risk": "HIGH"
        },
        {
            "address": "0x1234567890123456789012345678901234567890", 
            "name": "Medium-Risk Test Contract",
            "expected_risk": "MEDIUM"
        },
        {
            "address": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
            "name": "WETH (Low-Risk)",
            "expected_risk": "LOW"
        }
    ]
    
    # Import required modules
    try:
        import aiohttp
        from models.scorpius_models import ScanRequest, ScanType
        
        print("‚úÖ Required modules imported successfully")
        
    except ImportError as e:
        print(f"‚ùå Import error: {e}")
        print("Please ensure all dependencies are installed")
        print("Installing aiohttp...")
        
        # Try to install aiohttp if it's missing
        try:
            import subprocess
            import sys
            subprocess.check_call([sys.executable, "-m", "pip", "install", "aiohttp"])
            import aiohttp
            print("‚úÖ aiohttp installed and imported successfully")
        except Exception as install_error:
            print(f"‚ùå Failed to install aiohttp: {install_error}")
            return
    
    # Test each contract
    for i, contract in enumerate(test_contracts, 1):
        print(f"\nüîç TEST {i}/3: {contract['name']}")
        print(f"Address: {contract['address']}")
        print(f"Expected Risk: {contract['expected_risk']}")
        print("-" * 40)
        
        try:
            # Step 1: Start scan via API
            scan_result = await start_vulnerability_scan(contract['address'])
            
            if not scan_result:
                print(f"‚ùå Failed to start scan for {contract['address']}")
                continue
                
            scan_id = scan_result.get('scan_id')
            print(f"üìã Scan started: {scan_id}")
            
            # Step 2: Monitor scan progress
            final_results = await monitor_scan_progress(scan_id)
            
            if not final_results:
                print(f"‚ùå Failed to get scan results for {scan_id}")
                continue
            
            # Step 3: Analyze results
            await analyze_scan_results(contract, final_results)
            
            # Wait between tests
            if i < len(test_contracts):
                print("\n‚è±Ô∏è Waiting 3 seconds before next test...")
                await asyncio.sleep(3)
                
        except Exception as e:
            print(f"‚ùå Test failed for {contract['address']}: {e}")
    
    print("\n" + "=" * 60)
    print("üèÅ AUTONOMOUS EXPLOIT INTEGRATION TEST COMPLETE")


async def start_vulnerability_scan(contract_address: str) -> Dict[str, Any]:
    """Start a vulnerability scan using the Scorpius API"""
    
    try:
        scan_request = {
            "contract_address": contract_address,
            "scan_type": "comprehensive",
            "include_ai_analysis": True,
            "include_exploit_simulation": True,
            "priority": "high"
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                "http://localhost:8012/api/scorpius/scan/start",
                json=scan_request,
                timeout=30
            ) as response:
                
                if response.status == 200:
                    result = await response.json()
                    print(f"‚úÖ Scan request successful")
                    return result
                else:
                    print(f"‚ùå Scan request failed: {response.status}")
                    error_text = await response.text()
                    print(f"Error: {error_text}")
                    return None
                    
    except Exception as e:
        print(f"‚ùå Failed to start scan: {e}")
        return None


async def monitor_scan_progress(scan_id: str) -> Dict[str, Any]:
    """Monitor scan progress until completion"""
    
    print(f"üìä Monitoring scan progress for {scan_id}")
    max_wait_time = 300  # 5 minutes max
    start_time = time.time()
    
    try:
        async with aiohttp.ClientSession() as session:
            while time.time() - start_time < max_wait_time:
                
                # Check progress
                async with session.get(
                    f"http://localhost:8012/api/scorpius/scan/{scan_id}/progress",
                    timeout=10
                ) as response:
                    
                    if response.status == 200:
                        progress = await response.json()
                        status = progress.get('status', 'unknown')
                        progress_pct = progress.get('progress_percentage', 0)
                        current_stage = progress.get('current_stage', 'unknown')
                        
                        print(f"   Status: {status} | Progress: {progress_pct}% | Stage: {current_stage}")
                        
                        if status in ['completed', 'failed']:
                            break
                    else:
                        print(f"‚ùå Progress check failed: {response.status}")
                
                await asyncio.sleep(2)
            
            # Get final results
            async with session.get(
                f"http://localhost:8012/api/scorpius/scan/{scan_id}/results",
                timeout=30
            ) as response:
                
                if response.status == 200:
                    results = await response.json()
                    print(f"‚úÖ Scan completed successfully")
                    return results
                else:
                    print(f"‚ùå Failed to get results: {response.status}")
                    return None
                    
    except Exception as e:
        print(f"‚ùå Failed to monitor progress: {e}")
        return None


async def analyze_scan_results(contract: Dict[str, str], results: Dict[str, Any]) -> None:
    """Analyze and display scan results with focus on autonomous exploit outcomes"""
    
    print(f"\nüìä SCAN RESULTS ANALYSIS")
    print(f"Contract: {contract['name']}")
    print(f"Address: {contract['address']}")
    
    # Basic scan metrics
    vulnerabilities_found = results.get('vulnerabilities_found', 0)
    critical_count = results.get('critical_count', 0)
    high_count = results.get('high_count', 0)
    medium_count = results.get('medium_count', 0)
    low_count = results.get('low_count', 0)
    risk_score = results.get('risk_score', 0)
    scan_duration = results.get('scan_duration', 0)
    
    print(f"\nüîç Vulnerability Summary:")
    print(f"   Total Vulnerabilities: {vulnerabilities_found}")
    print(f"   Critical: {critical_count}")
    print(f"   High: {high_count}")
    print(f"   Medium: {medium_count}")
    print(f"   Low: {low_count}")
    print(f"   Risk Score: {risk_score}/100")
    print(f"   Scan Duration: {scan_duration:.2f}s")
    
    # Autonomous exploit analysis
    autonomous_exploit_executed = results.get('autonomous_exploit_executed', False)
    autonomous_exploit_results = results.get('autonomous_exploit_results', {})
    
    print(f"\nü§ñ AUTONOMOUS EXPLOIT ANALYSIS:")
    
    if risk_score > 60:
        print(f"   üö® HIGH-RISK CONTRACT DETECTED")
        print(f"   Risk Score: {risk_score} > 60 (Threshold)")
        
        if autonomous_exploit_executed:
            print(f"   ‚úÖ Autonomous Exploit Engine TRIGGERED")
            
            if autonomous_exploit_results:
                attacks_attempted = autonomous_exploit_results.get('attacks_attempted', 0)
                successful_exploits = autonomous_exploit_results.get('successful_exploits', 0)
                critical_exploits = autonomous_exploit_results.get('critical_exploits', 0)
                
                print(f"   üìä Exploit Results:")
                print(f"      - Attacks Attempted: {attacks_attempted}")
                print(f"      - Successful Exploits: {successful_exploits}")
                print(f"      - Critical Exploits: {critical_exploits}")
                
                if critical_exploits > 0:
                    print(f"   üî• CRITICAL EXPLOITS FOUND - Contract is highly vulnerable!")
                elif successful_exploits > 0:
                    print(f"   ‚ö†Ô∏è Exploitable vulnerabilities confirmed")
                else:
                    print(f"   ‚úÖ No successful exploits (contract appears secure)")
                
                # Show individual exploit results
                exploit_results = autonomous_exploit_results.get('exploit_results', [])
                if exploit_results:
                    print(f"\n   üéØ Individual Attack Results:")
                    for result in exploit_results:
                        attack_type = result.get('attack_type', 'unknown')
                        success = result.get('success', False)
                        impact_score = result.get('impact_score', 0)
                        funds_extractable = result.get('funds_extractable', '0 ETH')
                        
                        status = "‚úÖ SUCCESS" if success else "‚ùå FAILED"
                        print(f"      - {attack_type}: {status} (Impact: {impact_score}/10, Funds: {funds_extractable})")
            else:
                print(f"   ‚ùå Autonomous exploit failed or returned no results")
        else:
            print(f"   ‚ùå Autonomous Exploit Engine NOT EXECUTED")
            print(f"   Possible reasons: Engine not available, API error, or other failure")
    else:
        print(f"   ‚ÑπÔ∏è Low-Risk Contract")
        print(f"   Risk Score: {risk_score} ‚â§ 60 (Threshold)")
        print(f"   ‚úÖ Autonomous exploit simulation skipped (not needed)")
    
    # AI Analysis Summary
    ai_analysis = results.get('ai_analysis', {})
    if ai_analysis:
        summary = ai_analysis.get('summary', '')
        if summary:
            print(f"\nüß† AI Analysis Summary:")
            print(f"   {summary[:200]}{'...' if len(summary) > 200 else ''}")
    
    print(f"\n" + "-" * 50)


async def test_direct_autonomous_exploit():
    """Test the autonomous exploit engine directly (bypassing scanner)"""
    
    print("\nüéØ TESTING DIRECT AUTONOMOUS EXPLOIT")
    print("-" * 50)
    
    try:
        from modules.autonomous_exploit_engine import autonomous_exploit_if_high_risk
        
        test_address = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C"
        print(f"Testing direct exploit on: {test_address}")
        
        result = await autonomous_exploit_if_high_risk(test_address)
        
        print(f"‚úÖ Direct autonomous exploit test completed")
        print(f"Result: {json.dumps(result, indent=2)}")
        
    except ImportError:
        print(f"‚ùå Autonomous exploit engine not available")
    except Exception as e:
        print(f"‚ùå Direct exploit test failed: {e}")


if __name__ == "__main__":
    # Run the comprehensive test
    asyncio.run(test_autonomous_exploit_integration())
    
    # Also test direct autonomous exploit
    print("\n" + "=" * 60)
    asyncio.run(test_direct_autonomous_exploit())
