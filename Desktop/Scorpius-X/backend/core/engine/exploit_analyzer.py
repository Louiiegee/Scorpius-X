"""
Exploit Analyzer for Time Machine Replay Results
Analyzes replay execution results and generates insights about exploit behavior.
"""

import asyncio
import json
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import logging
from decimal import Decimal

logger = logging.getLogger(__name__)


@dataclass
class ExecutionMetrics:
    """Metrics for exploit execution analysis"""
    total_gas_used: int
    total_gas_cost: int
    execution_time_ms: int
    block_span: int
    transaction_count: int
    success_rate: float
    revert_count: int


@dataclass
class ProfitAnalysis:
    """Analysis of exploit profitability"""
    gross_profit: Decimal
    execution_costs: Decimal
    net_profit: Decimal
    roi_percentage: float
    profit_sources: Dict[str, Decimal]
    loss_sources: Dict[str, Decimal]


@dataclass
class VulnerabilityAnalysis:
    """Analysis of vulnerabilities exploited"""
    vulnerability_types: List[str]
    severity_scores: Dict[str, float]
    exploit_complexity: str
    mitigation_strategies: List[str]
    affected_functions: List[str]


@dataclass
class ReplayAnalysisResult:
    """Complete analysis result of exploit replay"""
    exploit_id: str
    success: bool
    execution_metrics: ExecutionMetrics
    profit_analysis: ProfitAnalysis
    vulnerability_analysis: VulnerabilityAnalysis
    state_changes: Dict[str, Any]
    risk_assessment: Dict[str, Any]
    recommendations: List[str]
    analysis_timestamp: datetime


class ExploitAnalyzer:
    """Analyzes exploit replay results and generates comprehensive insights"""
    
    def __init__(self):
        self.vulnerability_weights = {
            'reentrancy': 0.9,
            'oracle_manipulation': 0.8,
            'flash_loan': 0.7,
            'access_control': 0.85,
            'integer_overflow': 0.75,
            'front_running': 0.6,
            'sandwich_attack': 0.65
        }
        
        self.complexity_thresholds = {
            'simple': {'gas': 100000, 'transactions': 1, 'contracts': 1},
            'moderate': {'gas': 500000, 'transactions': 3, 'contracts': 3},
            'complex': {'gas': 1000000, 'transactions': 5, 'contracts': 5}
        }
    
    async def analyze_replay_result(self, 
                                  replay_result: Dict[str, Any], 
                                  original_exploit: Dict[str, Any] = None) -> ReplayAnalysisResult:
        """
        Analyze complete replay result and generate comprehensive insights
        
        Args:
            replay_result: Result from ReplayManager execution
            original_exploit: Original exploit data for comparison
            
        Returns:
            Complete analysis with metrics, profitability, and recommendations
        """
        try:
            logger.info(f"Analyzing replay result for exploit {replay_result.get('exploit_id', 'unknown')}")
            
            exploit_id = replay_result.get('exploit_id', 'unknown')
            
            # Extract execution data
            execution_data = replay_result.get('execution_results', [])
            trace_data = replay_result.get('trace_results', [])
            state_snapshots = replay_result.get('state_snapshots', {})
            
            # Analyze execution metrics
            execution_metrics = await self._analyze_execution_metrics(execution_data, trace_data)
            
            # Analyze profitability
            profit_analysis = await self._analyze_profitability(execution_data, state_snapshots)
            
            # Analyze vulnerabilities
            vulnerability_analysis = await self._analyze_vulnerabilities(execution_data, trace_data)
            
            # Analyze state changes
            state_changes = await self._analyze_state_changes(state_snapshots)
            
            # Perform risk assessment
            risk_assessment = await self._perform_risk_assessment(
                execution_metrics, profit_analysis, vulnerability_analysis
            )
            
            # Generate recommendations
            recommendations = await self._generate_recommendations(
                execution_metrics, profit_analysis, vulnerability_analysis, risk_assessment
            )
            
            # Determine overall success
            success = self._determine_success(execution_metrics, profit_analysis)
            
            analysis_result = ReplayAnalysisResult(
                exploit_id=exploit_id,
                success=success,
                execution_metrics=execution_metrics,
                profit_analysis=profit_analysis,
                vulnerability_analysis=vulnerability_analysis,
                state_changes=state_changes,
                risk_assessment=risk_assessment,
                recommendations=recommendations,
                analysis_timestamp=datetime.now()
            )
            
            logger.info(f"Analysis completed for exploit {exploit_id}: Success={success}")
            return analysis_result
            
        except Exception as e:
            logger.error(f"Replay analysis failed: {str(e)}")
            raise
    
    async def _analyze_execution_metrics(self, 
                                       execution_data: List[Dict[str, Any]], 
                                       trace_data: List[Dict[str, Any]]) -> ExecutionMetrics:
        """Analyze execution performance metrics"""
        try:
            if not execution_data:
                return ExecutionMetrics(0, 0, 0, 0, 0, 0.0, 0)
            
            total_gas = sum(result.get('gas_used', 0) for result in execution_data)
            total_gas_cost = sum(result.get('gas_cost', 0) for result in execution_data)
            
            # Calculate execution time from traces
            execution_times = [trace.get('execution_time', 0) for trace in trace_data]
            total_execution_time = sum(execution_times)
            
            # Calculate block span
            block_numbers = [result.get('block_number', 0) for result in execution_data]
            block_span = max(block_numbers) - min(block_numbers) if block_numbers else 0
            
            # Calculate success rate
            successful_txs = sum(1 for result in execution_data if result.get('success', False))
            success_rate = successful_txs / len(execution_data) if execution_data else 0.0
            revert_count = len(execution_data) - successful_txs
            
            return ExecutionMetrics(
                total_gas_used=total_gas,
                total_gas_cost=total_gas_cost,
                execution_time_ms=total_execution_time,
                block_span=block_span,
                transaction_count=len(execution_data),
                success_rate=success_rate,
                revert_count=revert_count
            )
            
        except Exception as e:
            logger.error(f"Execution metrics analysis failed: {str(e)}")
            return ExecutionMetrics(0, 0, 0, 0, 0, 0.0, 0)
    
    async def _analyze_profitability(self, 
                                   execution_data: List[Dict[str, Any]], 
                                   state_snapshots: Dict[str, Any]) -> ProfitAnalysis:
        """Analyze exploit profitability"""
        try:
            profit_sources = {}
            loss_sources = {}
            total_gas_cost = Decimal(0)
            
            # Calculate gas costs
            for result in execution_data:
                gas_cost = Decimal(result.get('gas_cost', 0))
                total_gas_cost += gas_cost
                loss_sources['gas_costs'] = total_gas_cost
            
            # Analyze balance changes from state snapshots
            balance_changes = self._analyze_balance_changes(state_snapshots)
            
            # Calculate profit from balance increases
            for address, change in balance_changes.items():
                if change > 0:
                    profit_sources[f'balance_increase_{address}'] = Decimal(change)
                else:
                    loss_sources[f'balance_decrease_{address}'] = Decimal(abs(change))
            
            # Calculate totals
            gross_profit = sum(profit_sources.values())
            total_losses = sum(loss_sources.values())
            net_profit = gross_profit - total_losses
            
            # Calculate ROI
            roi_percentage = 0.0
            if total_losses > 0:
                roi_percentage = float((net_profit / total_losses) * 100)
            
            return ProfitAnalysis(
                gross_profit=gross_profit,
                execution_costs=total_gas_cost,
                net_profit=net_profit,
                roi_percentage=roi_percentage,
                profit_sources=profit_sources,
                loss_sources=loss_sources
            )
            
        except Exception as e:
            logger.error(f"Profitability analysis failed: {str(e)}")
            return ProfitAnalysis(
                gross_profit=Decimal(0),
                execution_costs=Decimal(0),
                net_profit=Decimal(0),
                roi_percentage=0.0,
                profit_sources={},
                loss_sources={}
            )
    
    async def _analyze_vulnerabilities(self, 
                                     execution_data: List[Dict[str, Any]], 
                                     trace_data: List[Dict[str, Any]]) -> VulnerabilityAnalysis:
        """Analyze vulnerabilities exploited"""
        try:
            vulnerability_types = []
            severity_scores = {}
            affected_functions = []
            
            # Analyze traces for vulnerability patterns
            for trace in trace_data:
                trace_steps = trace.get('trace_steps', [])
                vuln_types = self._identify_vulnerability_patterns(trace_steps)
                vulnerability_types.extend(vuln_types)
                
                # Extract affected functions
                functions = [step.get('function_name') for step in trace_steps 
                           if step.get('function_name')]
                affected_functions.extend(functions)
            
            # Remove duplicates
            vulnerability_types = list(set(vulnerability_types))
            affected_functions = list(set(filter(None, affected_functions)))
            
            # Calculate severity scores
            for vuln_type in vulnerability_types:
                base_score = self.vulnerability_weights.get(vuln_type, 0.5)
                severity_scores[vuln_type] = base_score
            
            # Determine complexity
            complexity = self._determine_exploit_complexity(execution_data, trace_data)
            
            # Generate mitigation strategies
            mitigation_strategies = self._generate_mitigation_strategies(vulnerability_types)
            
            return VulnerabilityAnalysis(
                vulnerability_types=vulnerability_types,
                severity_scores=severity_scores,
                exploit_complexity=complexity,
                mitigation_strategies=mitigation_strategies,
                affected_functions=affected_functions
            )
            
        except Exception as e:
            logger.error(f"Vulnerability analysis failed: {str(e)}")
            return VulnerabilityAnalysis(
                vulnerability_types=[],
                severity_scores={},
                exploit_complexity='unknown',
                mitigation_strategies=[],
                affected_functions=[]
            )
    
    def _analyze_balance_changes(self, state_snapshots: Dict[str, Any]) -> Dict[str, int]:
        """Analyze balance changes between snapshots"""
        try:
            balance_changes = {}
            
            before_snapshot = state_snapshots.get('before', {})
            after_snapshot = state_snapshots.get('after', {})
            
            # Compare account balances
            before_balances = before_snapshot.get('account_states', {})
            after_balances = after_snapshot.get('account_states', {})
            
            all_addresses = set(before_balances.keys()) | set(after_balances.keys())
            
            for address in all_addresses:
                before_balance = before_balances.get(address, {}).get('balance', 0)
                after_balance = after_balances.get(address, {}).get('balance', 0)
                
                change = after_balance - before_balance
                if change != 0:
                    balance_changes[address] = change
            
            return balance_changes
            
        except Exception as e:
            logger.error(f"Balance change analysis failed: {str(e)}")
            return {}
    
    def _identify_vulnerability_patterns(self, trace_steps: List[Dict[str, Any]]) -> List[str]:
        """Identify vulnerability patterns from trace steps"""
        patterns = []
        
        try:
            # Look for reentrancy patterns
            external_calls = [step for step in trace_steps if step.get('opcode') == 'CALL']
            if len(external_calls) > 1:
                # Check for recursive calls to same contract
                call_targets = [call.get('to') for call in external_calls]
                if len(call_targets) != len(set(call_targets)):
                    patterns.append('reentrancy')
            
            # Look for delegate call patterns
            delegate_calls = [step for step in trace_steps if step.get('opcode') == 'DELEGATECALL']
            if delegate_calls:
                patterns.append('delegate_call_vulnerability')
            
            # Look for storage manipulation patterns
            storage_writes = [step for step in trace_steps if step.get('opcode') == 'SSTORE']
            if len(storage_writes) > 10:  # Excessive storage modifications
                patterns.append('state_manipulation')
            
            # Look for arithmetic patterns
            arithmetic_ops = [step for step in trace_steps 
                            if step.get('opcode') in ['ADD', 'SUB', 'MUL', 'DIV']]
            if len(arithmetic_ops) > 20:  # Complex arithmetic
                patterns.append('arithmetic_manipulation')
            
            return patterns
            
        except Exception as e:
            logger.error(f"Pattern identification failed: {str(e)}")
            return []
    
    def _determine_exploit_complexity(self, 
                                    execution_data: List[Dict[str, Any]], 
                                    trace_data: List[Dict[str, Any]]) -> str:
        """Determine exploit complexity level"""
        try:
            total_gas = sum(result.get('gas_used', 0) for result in execution_data)
            transaction_count = len(execution_data)
            
            # Count unique contracts involved
            contracts = set()
            for result in execution_data:
                if result.get('to'):
                    contracts.add(result['to'])
            contract_count = len(contracts)
            
            # Determine complexity based on thresholds
            if (total_gas <= self.complexity_thresholds['simple']['gas'] and
                transaction_count <= self.complexity_thresholds['simple']['transactions'] and
                contract_count <= self.complexity_thresholds['simple']['contracts']):
                return 'simple'
            
            elif (total_gas <= self.complexity_thresholds['complex']['gas'] and
                  transaction_count <= self.complexity_thresholds['complex']['transactions'] and
                  contract_count <= self.complexity_thresholds['complex']['contracts']):
                return 'moderate'
            
            else:
                return 'complex'
                
        except Exception:
            return 'unknown'
    
    def _generate_mitigation_strategies(self, vulnerability_types: List[str]) -> List[str]:
        """Generate mitigation strategies based on vulnerability types"""
        strategies = []
        
        mitigation_map = {
            'reentrancy': [
                'Implement checks-effects-interactions pattern',
                'Use reentrancy guards (nonReentrant modifier)',
                'Limit external calls and use pull payment pattern'
            ],
            'oracle_manipulation': [
                'Use multiple oracle sources',
                'Implement price validation and bounds checking',
                'Add time-weighted average pricing (TWAP)',
                'Use oracle aggregators like Chainlink'
            ],
            'flash_loan': [
                'Implement flash loan protection mechanisms',
                'Add transaction origin checks',
                'Use commit-reveal schemes for sensitive operations'
            ],
            'access_control': [
                'Implement proper role-based access control',
                'Use multi-signature requirements for critical functions',
                'Regular access control audits'
            ],
            'integer_overflow': [
                'Use SafeMath library or Solidity 0.8+ built-in checks',
                'Implement bounds checking for arithmetic operations',
                'Add overflow/underflow tests'
            ]
        }
        
        for vuln_type in vulnerability_types:
            if vuln_type in mitigation_map:
                strategies.extend(mitigation_map[vuln_type])
        
        return list(set(strategies))  # Remove duplicates
    
    async def _analyze_state_changes(self, state_snapshots: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze state changes between snapshots"""
        try:
            changes = {
                'balance_changes': {},
                'storage_changes': {},
                'code_changes': {},
                'nonce_changes': {}
            }
            
            before_snapshot = state_snapshots.get('before', {})
            after_snapshot = state_snapshots.get('after', {})
            
            if not before_snapshot or not after_snapshot:
                return changes
            
            # Analyze balance changes
            changes['balance_changes'] = self._analyze_balance_changes(state_snapshots)
            
            # Analyze storage changes
            before_storage = before_snapshot.get('contract_storage', {})
            after_storage = after_snapshot.get('contract_storage', {})
            
            for contract_addr in set(before_storage.keys()) | set(after_storage.keys()):
                before_slots = before_storage.get(contract_addr, {})
                after_slots = after_storage.get(contract_addr, {})
                
                storage_diff = {}
                for slot in set(before_slots.keys()) | set(after_slots.keys()):
                    before_val = before_slots.get(slot, '0x0')
                    after_val = after_slots.get(slot, '0x0')
                    
                    if before_val != after_val:
                        storage_diff[slot] = {'before': before_val, 'after': after_val}
                
                if storage_diff:
                    changes['storage_changes'][contract_addr] = storage_diff
            
            return changes
            
        except Exception as e:
            logger.error(f"State change analysis failed: {str(e)}")
            return {}
    
    async def _perform_risk_assessment(self, 
                                     execution_metrics: ExecutionMetrics,
                                     profit_analysis: ProfitAnalysis,
                                     vulnerability_analysis: VulnerabilityAnalysis) -> Dict[str, Any]:
        """Perform comprehensive risk assessment"""
        try:
            risk_score = 0.0
            risk_factors = []
            
            # Profitability risk
            if profit_analysis.net_profit > 1000:  # High profit exploits
                risk_score += 0.3
                risk_factors.append('High profitability increases attack incentive')
            
            # Complexity risk (lower complexity = higher risk of reproduction)
            if vulnerability_analysis.exploit_complexity == 'simple':
                risk_score += 0.2
                risk_factors.append('Simple exploit increases reproduction risk')
            
            # Vulnerability severity
            avg_severity = sum(vulnerability_analysis.severity_scores.values()) / len(
                vulnerability_analysis.severity_scores) if vulnerability_analysis.severity_scores else 0
            risk_score += avg_severity * 0.4
            
            # Success rate risk
            if execution_metrics.success_rate > 0.8:
                risk_score += 0.1
                risk_factors.append('High success rate increases reliability for attackers')
            
            # Categorize risk level
            if risk_score >= 0.8:
                risk_level = 'CRITICAL'
            elif risk_score >= 0.6:
                risk_level = 'HIGH'
            elif risk_score >= 0.4:
                risk_level = 'MEDIUM'
            else:
                risk_level = 'LOW'
            
            return {
                'risk_score': min(risk_score, 1.0),
                'risk_level': risk_level,
                'risk_factors': risk_factors,
                'immediate_threats': self._identify_immediate_threats(vulnerability_analysis),
                'long_term_risks': self._identify_long_term_risks(profit_analysis, vulnerability_analysis)
            }
            
        except Exception as e:
            logger.error(f"Risk assessment failed: {str(e)}")
            return {'risk_score': 0.0, 'risk_level': 'UNKNOWN', 'risk_factors': []}
    
    def _identify_immediate_threats(self, vulnerability_analysis: VulnerabilityAnalysis) -> List[str]:
        """Identify immediate security threats"""
        threats = []
        
        high_severity_vulns = [vuln for vuln, score in vulnerability_analysis.severity_scores.items() 
                              if score >= 0.8]
        
        if 'reentrancy' in high_severity_vulns:
            threats.append('Reentrancy attacks on critical functions')
        
        if 'oracle_manipulation' in high_severity_vulns:
            threats.append('Price oracle manipulation affecting protocol stability')
        
        if 'access_control' in high_severity_vulns:
            threats.append('Unauthorized access to privileged functions')
        
        return threats
    
    def _identify_long_term_risks(self, 
                                profit_analysis: ProfitAnalysis,
                                vulnerability_analysis: VulnerabilityAnalysis) -> List[str]:
        """Identify long-term security risks"""
        risks = []
        
        if profit_analysis.roi_percentage > 1000:  # 10x ROI
            risks.append('High ROI may attract sophisticated attackers')
        
        if len(vulnerability_analysis.vulnerability_types) > 3:
            risks.append('Multiple vulnerabilities indicate systemic security issues')
        
        if vulnerability_analysis.exploit_complexity == 'simple':
            risks.append('Simple exploits may lead to copycat attacks')
        
        return risks
    
    async def _generate_recommendations(self, 
                                      execution_metrics: ExecutionMetrics,
                                      profit_analysis: ProfitAnalysis,
                                      vulnerability_analysis: VulnerabilityAnalysis,
                                      risk_assessment: Dict[str, Any]) -> List[str]:
        """Generate actionable security recommendations"""
        recommendations = []
        
        try:
            # High-level recommendations based on risk level
            risk_level = risk_assessment.get('risk_level', 'UNKNOWN')
            
            if risk_level == 'CRITICAL':
                recommendations.append('URGENT: Implement emergency pause mechanism')
                recommendations.append('URGENT: Notify users and pause vulnerable functions')
            
            elif risk_level == 'HIGH':
                recommendations.append('Prioritize immediate security patches')
                recommendations.append('Consider temporary restrictions on affected functions')
            
            # Specific vulnerability recommendations
            recommendations.extend(vulnerability_analysis.mitigation_strategies)
            
            # Profitability-based recommendations
            if profit_analysis.net_profit > 1000:
                recommendations.append('Implement MEV protection mechanisms')
                recommendations.append('Consider using commit-reveal schemes')
            
            # Success rate recommendations
            if execution_metrics.success_rate > 0.9:
                recommendations.append('Add randomness or unpredictability to critical operations')
            
            # Gas-based recommendations
            if execution_metrics.total_gas_used > 1000000:
                recommendations.append('Optimize gas usage to reduce attack profitability')
            
            return list(set(recommendations))  # Remove duplicates
            
        except Exception as e:
            logger.error(f"Recommendation generation failed: {str(e)}")
            return ['Conduct comprehensive security audit']
    
    def _determine_success(self, 
                         execution_metrics: ExecutionMetrics, 
                         profit_analysis: ProfitAnalysis) -> bool:
        """Determine if exploit replay was successful"""
        try:
            # Success criteria
            criteria = [
                execution_metrics.success_rate > 0.5,  # Most transactions succeeded
                execution_metrics.revert_count == 0,   # No reverted transactions
                profit_analysis.net_profit > 0         # Positive profit
            ]
            
            # Exploit is successful if majority of criteria are met
            return sum(criteria) >= 2
            
        except Exception:
            return False


async def create_exploit_analyzer() -> ExploitAnalyzer:
    """Factory function to create ExploitAnalyzer"""
    try:
        return ExploitAnalyzer()
    except Exception as e:
        logger.error(f"Failed to create ExploitAnalyzer: {str(e)}")
        raise
