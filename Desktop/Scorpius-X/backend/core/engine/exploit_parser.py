"""
Exploit Parser for Blockchain Time Machine
Parses exploit configurations and identifies exploit types and vulnerability vectors.
"""

import json
import re
from typing import Dict, List, Any, Optional, Union, Tuple
from datetime import datetime
from dataclasses import dataclass, asdict
from enum import Enum
import logging
from web3 import Web3

logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Enumeration of exploit types"""
    REENTRANCY = "reentrancy"
    ORACLE_MANIPULATION = "oracle_manipulation"
    FLASH_LOAN = "flash_loan"
    INTEGER_OVERFLOW = "integer_overflow"
    ACCESS_CONTROL = "access_control"
    FRONT_RUNNING = "front_running"
    SANDWICH_ATTACK = "sandwich_attack"
    MEV = "mev"
    GOVERNANCE = "governance"
    BRIDGE_EXPLOIT = "bridge_exploit"
    DEFI_PROTOCOL = "defi_protocol"
    UNKNOWN = "unknown"


class VulnerabilityVector(Enum):
    """Enumeration of vulnerability vectors"""
    EXTERNAL_CALL = "external_call"
    DELEGATE_CALL = "delegate_call"
    PRICE_ORACLE = "price_oracle"
    ARITHMETIC = "arithmetic"
    AUTHORIZATION = "authorization"
    STATE_MANIPULATION = "state_manipulation"
    TRANSACTION_ORDERING = "transaction_ordering"
    ECONOMIC = "economic"
    CONSENSUS = "consensus"


@dataclass
class ExploitPattern:
    """Pattern definition for exploit detection"""
    name: str
    exploit_type: ExploitType
    vulnerability_vectors: List[VulnerabilityVector]
    signature_patterns: List[str]
    bytecode_patterns: List[str]
    transaction_patterns: List[str]
    confidence_threshold: float = 0.7


@dataclass
class ParsedExploit:
    """Parsed exploit configuration"""
    exploit_id: str
    exploit_type: ExploitType
    vulnerability_vectors: List[VulnerabilityVector]
    target_contract: str
    attack_transactions: List[str]
    preparation_transactions: List[str]
    parameters: Dict[str, Any]
    estimated_profit: Optional[float] = None
    gas_requirements: Optional[int] = None
    time_constraints: Optional[Dict[str, Any]] = None
    success_conditions: List[str] = None
    
    def __post_init__(self):
        if self.success_conditions is None:
            self.success_conditions = []


class ExploitParser:
    """Parses and analyzes exploit configurations"""
    
    def __init__(self, web3_provider: Web3 = None):
        self.w3 = web3_provider
        self.exploit_patterns = self._load_exploit_patterns()
        self.function_signatures = self._load_function_signatures()
        self.event_signatures = self._load_event_signatures()
    
    async def parse_exploit(self, exploit_data: Dict[str, Any]) -> ParsedExploit:
        """
        Parse exploit configuration and identify attack patterns
        
        Args:
            exploit_data: Raw exploit data from database or input
            
        Returns:
            ParsedExploit with analyzed configuration
        """
        try:
            logger.info(f"Parsing exploit {exploit_data.get('id', 'unknown')}")
            
            # Extract basic information
            exploit_id = exploit_data.get('id', 'unknown')
            contract_address = exploit_data.get('contract_address')
            transaction_hashes = exploit_data.get('transaction_hashes', [])
            
            # Analyze exploit type
            exploit_type = await self._identify_exploit_type(exploit_data)
            
            # Identify vulnerability vectors
            vulnerability_vectors = await self._identify_vulnerability_vectors(exploit_data)
            
            # Parse transaction sequence
            attack_txs, prep_txs = await self._parse_transaction_sequence(transaction_hashes)
            
            # Extract parameters
            parameters = await self._extract_exploit_parameters(exploit_data)
            
            # Estimate profit and requirements
            estimated_profit = await self._estimate_profit(exploit_data, attack_txs)
            gas_requirements = await self._estimate_gas_requirements(attack_txs)
            
            # Identify time constraints
            time_constraints = await self._identify_time_constraints(exploit_data)
            
            # Define success conditions
            success_conditions = await self._define_success_conditions(exploit_type, parameters)
            
            parsed_exploit = ParsedExploit(
                exploit_id=exploit_id,
                exploit_type=exploit_type,
                vulnerability_vectors=vulnerability_vectors,
                target_contract=contract_address,
                attack_transactions=attack_txs,
                preparation_transactions=prep_txs,
                parameters=parameters,
                estimated_profit=estimated_profit,
                gas_requirements=gas_requirements,
                time_constraints=time_constraints,
                success_conditions=success_conditions
            )
            
            logger.info(f"Successfully parsed exploit {exploit_id}: {exploit_type.value}")
            return parsed_exploit
            
        except Exception as e:
            logger.error(f"Failed to parse exploit: {str(e)}")
            raise
    
    async def _identify_exploit_type(self, exploit_data: Dict[str, Any]) -> ExploitType:
        """Identify the type of exploit based on patterns and data"""
        try:
            # Check explicit type
            explicit_type = exploit_data.get('exploit_type')
            if explicit_type:
                try:
                    return ExploitType(explicit_type.lower())
                except ValueError:
                    pass
            
            # Analyze transaction patterns
            transaction_hashes = exploit_data.get('transaction_hashes', [])
            if transaction_hashes:
                return await self._analyze_transaction_patterns(transaction_hashes)
            
            # Analyze contract code patterns
            contract_address = exploit_data.get('contract_address')
            if contract_address and self.w3:
                return await self._analyze_contract_patterns(contract_address)
            
            # Analyze description/metadata
            description = exploit_data.get('description', '').lower()
            return self._analyze_description_patterns(description)
            
        except Exception as e:
            logger.warning(f"Exploit type identification failed: {str(e)}")
            return ExploitType.UNKNOWN
    
    async def _identify_vulnerability_vectors(self, exploit_data: Dict[str, Any]) -> List[VulnerabilityVector]:
        """Identify vulnerability vectors used in the exploit"""
        vectors = []
        
        try:
            # Analyze transaction data for vectors
            transaction_hashes = exploit_data.get('transaction_hashes', [])
            for tx_hash in transaction_hashes:
                if self.w3:
                    try:
                        tx = self.w3.eth.get_transaction(tx_hash)
                        tx_vectors = await self._analyze_transaction_vectors(tx)
                        vectors.extend(tx_vectors)
                    except Exception:
                        continue
            
            # Analyze parameters for vector hints
            parameters = exploit_data.get('parameters', {})
            param_vectors = self._analyze_parameter_vectors(parameters)
            vectors.extend(param_vectors)
            
            # Remove duplicates
            return list(set(vectors))
            
        except Exception as e:
            logger.warning(f"Vulnerability vector identification failed: {str(e)}")
            return []
    
    async def _parse_transaction_sequence(self, transaction_hashes: List[str]) -> Tuple[List[str], List[str]]:
        """Parse transaction sequence into attack and preparation transactions"""
        try:
            if not transaction_hashes or not self.w3:
                return transaction_hashes, []
            
            # Get transaction details
            transactions = []
            for tx_hash in transaction_hashes:
                try:
                    tx = self.w3.eth.get_transaction(tx_hash)
                    receipt = self.w3.eth.get_transaction_receipt(tx_hash)
                    transactions.append((tx, receipt))
                except Exception:
                    continue
            
            # Sort by block number and transaction index
            transactions.sort(key=lambda x: (x[0].blockNumber, x[0].transactionIndex))
            
            # Analyze for preparation vs attack transactions
            attack_txs = []
            prep_txs = []
            
            for tx, receipt in transactions:
                if self._is_attack_transaction(tx, receipt):
                    attack_txs.append(tx.hash.hex())
                else:
                    prep_txs.append(tx.hash.hex())
            
            return attack_txs, prep_txs
            
        except Exception as e:
            logger.warning(f"Transaction sequence parsing failed: {str(e)}")
            return transaction_hashes, []
    
    def _is_attack_transaction(self, tx: Dict[str, Any], receipt: Dict[str, Any]) -> bool:
        """Determine if transaction is part of main attack or preparation"""
        try:
            # High value transactions are likely attack
            if tx.value > 10**18:  # > 1 ETH
                return True
            
            # High gas usage might indicate complex attack
            if receipt.gasUsed > 500000:
                return True
            
            # Multiple events might indicate attack
            if len(receipt.logs) > 10:
                return True
            
            # Failed transactions are likely attack attempts
            if receipt.status == 0:
                return True
            
            return False
            
        except Exception:
            return True  # Default to attack if analysis fails
    
    async def _extract_exploit_parameters(self, exploit_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract relevant parameters from exploit data"""
        try:
            parameters = exploit_data.get('parameters', {})
            
            # Add computed parameters
            if 'transaction_hashes' in exploit_data:
                parameters['transaction_count'] = len(exploit_data['transaction_hashes'])
            
            if 'block_number' in exploit_data:
                parameters['target_block'] = exploit_data['block_number']
            
            # Extract monetary amounts
            parameters.update(await self._extract_monetary_parameters(exploit_data))
            
            # Extract timing parameters
            parameters.update(await self._extract_timing_parameters(exploit_data))
            
            return parameters
            
        except Exception as e:
            logger.warning(f"Parameter extraction failed: {str(e)}")
            return {}
    
    async def _estimate_profit(self, exploit_data: Dict[str, Any], attack_txs: List[str]) -> Optional[float]:
        """Estimate profit from the exploit"""
        try:
            if not attack_txs or not self.w3:
                return None
            
            total_profit = 0.0
            
            for tx_hash in attack_txs:
                try:
                    tx = self.w3.eth.get_transaction(tx_hash)
                    receipt = self.w3.eth.get_transaction_receipt(tx_hash)
                    
                    # Simple profit estimation based on value transfer
                    if tx.value > 0:
                        total_profit += float(tx.value) / 10**18  # Convert to ETH
                    
                    # Analyze logs for token transfers
                    token_profit = self._analyze_token_transfers(receipt.logs)
                    total_profit += token_profit
                    
                except Exception:
                    continue
            
            return total_profit if total_profit > 0 else None
            
        except Exception as e:
            logger.warning(f"Profit estimation failed: {str(e)}")
            return None
    
    def _analyze_token_transfers(self, logs: List[Dict[str, Any]]) -> float:
        """Analyze logs for token transfers and estimate value"""
        try:
            # ERC20 Transfer event signature
            transfer_topic = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
            
            total_value = 0.0
            
            for log in logs:
                if log.topics and log.topics[0].hex() == transfer_topic:
                    # This is a Transfer event - would need price data to estimate value
                    # For now, just count transfers
                    total_value += 0.1  # Placeholder
            
            return total_value
            
        except Exception:
            return 0.0
    
    async def _estimate_gas_requirements(self, attack_txs: List[str]) -> Optional[int]:
        """Estimate total gas requirements for exploit"""
        try:
            if not attack_txs or not self.w3:
                return None
            
            total_gas = 0
            
            for tx_hash in attack_txs:
                try:
                    receipt = self.w3.eth.get_transaction_receipt(tx_hash)
                    total_gas += receipt.gasUsed
                except Exception:
                    continue
            
            return total_gas if total_gas > 0 else None
            
        except Exception as e:
            logger.warning(f"Gas estimation failed: {str(e)}")
            return None
    
    async def _identify_time_constraints(self, exploit_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Identify time-sensitive constraints for the exploit"""
        try:
            constraints = {}
            
            # Block time constraints
            if 'block_number' in exploit_data:
                constraints['target_block'] = exploit_data['block_number']
            
            # Transaction ordering constraints
            transaction_hashes = exploit_data.get('transaction_hashes', [])
            if len(transaction_hashes) > 1:
                constraints['requires_ordering'] = True
                constraints['max_block_gap'] = 1  # Must be in consecutive blocks
            
            # MEV constraints
            if self._has_mev_characteristics(exploit_data):
                constraints['mev_sensitive'] = True
                constraints['max_delay_blocks'] = 0  # Must be immediate
            
            return constraints if constraints else None
            
        except Exception as e:
            logger.warning(f"Time constraint identification failed: {str(e)}")
            return None
    
    def _has_mev_characteristics(self, exploit_data: Dict[str, Any]) -> bool:
        """Check if exploit has MEV characteristics"""
        exploit_type = exploit_data.get('exploit_type', '').lower()
        description = exploit_data.get('description', '').lower()
        
        mev_keywords = ['sandwich', 'front', 'arbitrage', 'mev', 'flashloan']
        
        return any(keyword in exploit_type or keyword in description for keyword in mev_keywords)
    
    async def _define_success_conditions(self, exploit_type: ExploitType, parameters: Dict[str, Any]) -> List[str]:
        """Define conditions that indicate successful exploit execution"""
        conditions = []
        
        try:
            # Common conditions for all exploits
            conditions.append("All transactions executed successfully")
            conditions.append("No reverted transactions")
            
            # Type-specific conditions
            if exploit_type == ExploitType.REENTRANCY:
                conditions.append("Recursive call pattern detected")
                conditions.append("Balance increased through reentrancy")
            
            elif exploit_type == ExploitType.ORACLE_MANIPULATION:
                conditions.append("Price oracle value changed")
                conditions.append("Arbitrage profit captured")
            
            elif exploit_type == ExploitType.FLASH_LOAN:
                conditions.append("Flash loan borrowed and repaid")
                conditions.append("Net profit after loan fees")
            
            elif exploit_type == ExploitType.ACCESS_CONTROL:
                conditions.append("Unauthorized function executed")
                conditions.append("Privilege escalation achieved")
            
            # Add parameter-based conditions
            if 'target_profit' in parameters:
                conditions.append(f"Profit exceeds {parameters['target_profit']} ETH")
            
            if 'gas_limit' in parameters:
                conditions.append(f"Gas usage within {parameters['gas_limit']} limit")
            
            return conditions
            
        except Exception as e:
            logger.warning(f"Success condition definition failed: {str(e)}")
            return ["Transaction execution completed"]
    
    async def _analyze_transaction_patterns(self, transaction_hashes: List[str]) -> ExploitType:
        """Analyze transaction patterns to identify exploit type"""
        try:
            if not self.w3:
                return ExploitType.UNKNOWN
            
            # Pattern indicators
            has_flash_loan = False
            has_complex_calls = False
            has_high_value = False
            call_pattern_score = 0
            
            for tx_hash in transaction_hashes:
                try:
                    tx = self.w3.eth.get_transaction(tx_hash)
                    receipt = self.w3.eth.get_transaction_receipt(tx_hash)
                    
                    # Check for flash loan patterns
                    if self._detect_flash_loan_pattern(tx, receipt):
                        has_flash_loan = True
                    
                    # Check for complex calls
                    if len(receipt.logs) > 20 or receipt.gasUsed > 1000000:
                        has_complex_calls = True
                    
                    # Check for high value
                    if tx.value > 10**18:  # > 1 ETH
                        has_high_value = True
                    
                    # Analyze call patterns
                    call_pattern_score += self._analyze_call_patterns(tx.input)
                    
                except Exception:
                    continue
            
            # Determine exploit type based on patterns
            if has_flash_loan:
                return ExploitType.FLASH_LOAN
            elif call_pattern_score > 3:
                return ExploitType.REENTRANCY
            elif has_complex_calls and has_high_value:
                return ExploitType.DEFI_PROTOCOL
            else:
                return ExploitType.UNKNOWN
                
        except Exception as e:
            logger.warning(f"Transaction pattern analysis failed: {str(e)}")
            return ExploitType.UNKNOWN
    
    def _detect_flash_loan_pattern(self, tx: Dict[str, Any], receipt: Dict[str, Any]) -> bool:
        """Detect flash loan patterns in transaction"""
        try:
            # Check for flash loan function signatures
            flash_loan_sigs = [
                "0x5cffe9de",  # flashLoan
                "0x1b0e35b5",  # flashLoanMultiple
                "0x8aca6c14"   # executeFlashLoan
            ]
            
            input_data = tx.input.hex()
            for sig in flash_loan_sigs:
                if input_data.startswith(sig):
                    return True
            
            # Check for flash loan events
            flash_loan_topics = [
                "0x631c1b8f",  # FlashLoan event
                "0x1b7b4d7b"   # FlashLoanMultiple event
            ]
            
            for log in receipt.logs:
                if log.topics and any(log.topics[0].hex().startswith(topic) for topic in flash_loan_topics):
                    return True
            
            return False
            
        except Exception:
            return False
    
    def _analyze_call_patterns(self, input_data: str) -> int:
        """Analyze input data for suspicious call patterns"""
        try:
            # Look for patterns indicating reentrancy or complex interactions
            score = 0
            
            # Multiple function calls in single transaction
            if len(input_data) > 1000:  # Large input suggests complex interaction
                score += 1
            
            # Look for delegatecall patterns
            if "delegatecall" in input_data.lower():
                score += 2
            
            # Look for external call patterns
            external_call_patterns = ["call(", "staticcall(", "delegatecall("]
            for pattern in external_call_patterns:
                if pattern in input_data.lower():
                    score += 1
            
            return score
            
        except Exception:
            return 0
    
    async def _analyze_contract_patterns(self, contract_address: str) -> ExploitType:
        """Analyze contract bytecode for exploit type indicators"""
        try:
            code = self.w3.eth.get_code(contract_address)
            if not code:
                return ExploitType.UNKNOWN
            
            bytecode = code.hex()
            
            # Pattern matching on bytecode
            if "delegatecall" in bytecode.lower():
                return ExploitType.ACCESS_CONTROL
            
            if len(bytecode) < 100:  # Very small contract might be proxy
                return ExploitType.ACCESS_CONTROL
            
            # Look for oracle-related patterns
            oracle_patterns = ["latestRoundData", "getPrice", "oracle"]
            if any(pattern in bytecode.lower() for pattern in oracle_patterns):
                return ExploitType.ORACLE_MANIPULATION
            
            return ExploitType.UNKNOWN
            
        except Exception as e:
            logger.warning(f"Contract pattern analysis failed: {str(e)}")
            return ExploitType.UNKNOWN
    
    def _analyze_description_patterns(self, description: str) -> ExploitType:
        """Analyze description text for exploit type indicators"""
        description = description.lower()
        
        # Keyword mapping
        type_keywords = {
            ExploitType.REENTRANCY: ["reentrancy", "reentrant", "recursive", "callback"],
            ExploitType.ORACLE_MANIPULATION: ["oracle", "price", "manipulation", "arbitrage"],
            ExploitType.FLASH_LOAN: ["flash", "loan", "flashloan", "borrow"],
            ExploitType.INTEGER_OVERFLOW: ["overflow", "underflow", "arithmetic", "integer"],
            ExploitType.ACCESS_CONTROL: ["access", "control", "permission", "authorization", "admin"],
            ExploitType.FRONT_RUNNING: ["front", "running", "frontrun", "mev"],
            ExploitType.SANDWICH_ATTACK: ["sandwich", "slippage"],
            ExploitType.GOVERNANCE: ["governance", "voting", "proposal"],
            ExploitType.BRIDGE_EXPLOIT: ["bridge", "crosschain", "cross-chain"]
        }
        
        # Score each type
        type_scores = {}
        for exploit_type, keywords in type_keywords.items():
            score = sum(1 for keyword in keywords if keyword in description)
            if score > 0:
                type_scores[exploit_type] = score
        
        # Return highest scoring type
        if type_scores:
            return max(type_scores.keys(), key=lambda x: type_scores[x])
        
        return ExploitType.UNKNOWN
    
    async def _analyze_transaction_vectors(self, tx: Dict[str, Any]) -> List[VulnerabilityVector]:
        """Analyze transaction for vulnerability vectors"""
        vectors = []
        
        try:
            # Analyze input data
            input_data = tx.input.hex()
            
            # External call patterns
            if any(pattern in input_data.lower() for pattern in ["call", "delegatecall"]):
                vectors.append(VulnerabilityVector.EXTERNAL_CALL)
            
            if "delegatecall" in input_data.lower():
                vectors.append(VulnerabilityVector.DELEGATE_CALL)
            
            # High value suggests economic vector
            if tx.value > 10**17:  # > 0.1 ETH
                vectors.append(VulnerabilityVector.ECONOMIC)
            
            # Complex input suggests state manipulation
            if len(input_data) > 500:
                vectors.append(VulnerabilityVector.STATE_MANIPULATION)
            
            return vectors
            
        except Exception:
            return []
    
    def _analyze_parameter_vectors(self, parameters: Dict[str, Any]) -> List[VulnerabilityVector]:
        """Analyze parameters for vulnerability vector hints"""
        vectors = []
        
        # Look for oracle-related parameters
        oracle_params = ["price", "oracle", "feed", "rate"]
        if any(param in str(parameters).lower() for param in oracle_params):
            vectors.append(VulnerabilityVector.PRICE_ORACLE)
        
        # Look for authorization parameters
        auth_params = ["admin", "owner", "role", "permission"]
        if any(param in str(parameters).lower() for param in auth_params):
            vectors.append(VulnerabilityVector.AUTHORIZATION)
        
        return vectors
    
    async def _extract_monetary_parameters(self, exploit_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract monetary parameters from exploit data"""
        params = {}
        
        try:
            # Extract amounts from transaction values
            if self.w3 and 'transaction_hashes' in exploit_data:
                total_value = 0
                for tx_hash in exploit_data['transaction_hashes']:
                    try:
                        tx = self.w3.eth.get_transaction(tx_hash)
                        total_value += tx.value
                    except Exception:
                        continue
                
                if total_value > 0:
                    params['total_value_wei'] = total_value
                    params['total_value_eth'] = float(total_value) / 10**18
            
            return params
            
        except Exception:
            return {}
    
    async def _extract_timing_parameters(self, exploit_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract timing-related parameters"""
        params = {}
        
        try:
            if 'block_number' in exploit_data:
                params['target_block_number'] = exploit_data['block_number']
            
            # Calculate transaction span
            if self.w3 and 'transaction_hashes' in exploit_data:
                block_numbers = []
                for tx_hash in exploit_data['transaction_hashes']:
                    try:
                        tx = self.w3.eth.get_transaction(tx_hash)
                        block_numbers.append(tx.blockNumber)
                    except Exception:
                        continue
                
                if len(block_numbers) > 1:
                    params['block_span'] = max(block_numbers) - min(block_numbers)
                    params['requires_sequencing'] = params['block_span'] <= 1
            
            return params
            
        except Exception:
            return {}
    
    def _load_exploit_patterns(self) -> List[ExploitPattern]:
        """Load predefined exploit patterns"""
        patterns = [
            ExploitPattern(
                name="Classic Reentrancy",
                exploit_type=ExploitType.REENTRANCY,
                vulnerability_vectors=[VulnerabilityVector.EXTERNAL_CALL],
                signature_patterns=["withdraw", "call"],
                bytecode_patterns=["CALL", "SLOAD", "SSTORE"],
                transaction_patterns=["recursive_calls"],
                confidence_threshold=0.8
            ),
            ExploitPattern(
                name="Oracle Price Manipulation",
                exploit_type=ExploitType.ORACLE_MANIPULATION,
                vulnerability_vectors=[VulnerabilityVector.PRICE_ORACLE, VulnerabilityVector.ECONOMIC],
                signature_patterns=["getPrice", "latestRoundData", "swap"],
                bytecode_patterns=["STATICCALL", "CALL"],
                transaction_patterns=["price_impact"],
                confidence_threshold=0.7
            ),
            ExploitPattern(
                name="Flash Loan Attack",
                exploit_type=ExploitType.FLASH_LOAN,
                vulnerability_vectors=[VulnerabilityVector.ECONOMIC, VulnerabilityVector.STATE_MANIPULATION],
                signature_patterns=["flashLoan", "executeFlashLoan"],
                bytecode_patterns=["CALL", "DELEGATECALL"],
                transaction_patterns=["borrow_repay"],
                confidence_threshold=0.9
            )
        ]
        
        return patterns
    
    def _load_function_signatures(self) -> Dict[str, str]:
        """Load common function signatures"""
        return {
            "0xa9059cbb": "transfer(address,uint256)",
            "0x23b872dd": "transferFrom(address,address,uint256)",
            "0x095ea7b3": "approve(address,uint256)",
            "0x70a08231": "balanceOf(address)",
            "0x18160ddd": "totalSupply()",
            "0x313ce567": "decimals()",
            "0x95d89b41": "symbol()",
            "0x06fdde03": "name()",
            "0x5cffe9de": "flashLoan(address,uint256,bytes)",
            "0x1b0e35b5": "flashLoanMultiple(address[],uint256[],bytes)"
        }
    
    def _load_event_signatures(self) -> Dict[str, str]:
        """Load common event signatures"""
        return {
            "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef": "Transfer(address,address,uint256)",
            "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925": "Approval(address,address,uint256)",
            "0x631c1b8f82dc4a8f0e3c5bc7c7b7e5f5c1df7d1b9f5e3b8e7a6e4f8c2d1b0a9f": "FlashLoan(address,uint256,uint256)",
            "0x1b7b4d7b1e3c4f5b2e8d9c6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6": "FlashLoanMultiple(address[],uint256[],uint256[])"
        }


async def create_exploit_parser(web3_url: str = None) -> ExploitParser:
    """Factory function to create ExploitParser"""
    try:
        w3 = None
        if web3_url:
            w3 = Web3(Web3.HTTPProvider(web3_url))
            if not w3.is_connected():
                logger.warning("Web3 connection failed, parser will work with limited functionality")
                w3 = None
        
        return ExploitParser(w3)
        
    except Exception as e:
        logger.error(f"Failed to create ExploitParser: {str(e)}")
        raise
