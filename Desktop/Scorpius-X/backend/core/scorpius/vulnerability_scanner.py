"""
Scorpius Advanced Vulnerability Scanner
Integrates AI analysis with existing exploit suite + Autonomous Exploit Engine
"""
import asyncio
import json
import logging
import subprocess
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
import uuid
import os
import aiohttp
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from models.scorpius_models import (
    ScorpiusScan, ScanStatus, ScanType, VulnerabilityLevel,
    VulnerabilityFinding, ScorpiusAnalysis, ContractInfo,
    ScanRequest, ScanResponse, ScanProgress
)
from core.scorpius.ai_analyzer import ClaudeAnalyzer
from core.scorpius.report_generator import ReportGenerator

# Import autonomous exploit engine
try:
    from modules.autonomous_exploit_engine import autonomous_exploit_if_high_risk
    AUTONOMOUS_EXPLOIT_AVAILABLE = True
except ImportError as e:
    AUTONOMOUS_EXPLOIT_AVAILABLE = False
    
logger = logging.getLogger(__name__)

if AUTONOMOUS_EXPLOIT_AVAILABLE:
    logger.info("✅ Autonomous Exploit Engine integrated with Scorpius Scanner")
else:
    logger.warning("⚠️ Autonomous Exploit Engine not available")

class ScorpiusVulnerabilityScanner:
    """Advanced vulnerability scanner with AI integration"""
    
    def __init__(self, db_session: AsyncSession, anthropic_api_key: Optional[str] = None):
        self.db = db_session
        self.ai_analyzer = ClaudeAnalyzer(anthropic_api_key)
        self.report_generator = ReportGenerator()
        self.exploit_suite_path = Path("C:/Users/ADMIN/Desktop/advanced_exploit_suite")
        
    async def start_scan(self, request: ScanRequest) -> ScanResponse:
        """
        Start a new Scorpius vulnerability scan
        
        Args:
            request: Scan configuration request
            
        Returns:
            ScanResponse with scan_id and status
        """
        try:
            # Create scan record
            scan_id = str(uuid.uuid4())
            
            scan = ScorpiusScan(
                id=scan_id,
                contract_address=request.contract_address,
                chain=request.chain,
                scan_type=request.scan_type.value,
                status=ScanStatus.PENDING.value,
                scan_config=request.__dict__,
                ai_model="claude-3-opus",
                user_id="scorpius_user"
            )
            
            self.db.add(scan)
            await self.db.commit()
            
            # Start background scan
            asyncio.create_task(self._execute_scan(scan_id, request))
            
            return ScanResponse(
                scan_id=scan_id,
                status=ScanStatus.PENDING,
                message="Scan initiated successfully",
                estimated_duration=300  # 5 minutes estimate
            )
            
        except Exception as e:
            logger.error(f"Failed to start scan: {e}")
            return ScanResponse(
                scan_id="",
                status=ScanStatus.FAILED,
                message=f"Failed to start scan: {str(e)}"
            )
    
    async def get_scan_progress(self, scan_id: str) -> Optional[ScanProgress]:
        """Get scan progress information"""
        try:
            result = await self.db.execute(
                select(ScorpiusScan).filter(ScorpiusScan.id == scan_id)
            )
            scan = result.scalar_one_or_none()
            
            if not scan:
                return None
            
            # Calculate progress based on status
            progress_map = {
                ScanStatus.PENDING.value: 0.0,
                ScanStatus.RUNNING.value: 0.3,
                ScanStatus.ANALYZING.value: 0.7,
                ScanStatus.GENERATING_REPORT.value: 0.9,
                ScanStatus.COMPLETED.value: 1.0,
                ScanStatus.FAILED.value: 0.0
            }
            
            return ScanProgress(
                scan_id=scan_id,
                status=ScanStatus(scan.status),
                progress=progress_map.get(scan.status, 0.0),
                current_stage=scan.status.replace("_", " ").title(),
                stages_completed=self._get_completed_stages(scan.status),
                vulnerabilities_found=scan.vulnerabilities_found or 0
            )
            
        except Exception as e:
            logger.error(f"Failed to get scan progress: {e}")
            return None
    
    async def get_scan_results(self, scan_id: str) -> Optional[ScorpiusScan]:
        """Get completed scan results"""
        try:
            result = await self.db.execute(
                select(ScorpiusScan).filter(ScorpiusScan.id == scan_id)
            )
            return result.scalar_one_or_none()
            
        except Exception as e:
            logger.error(f"Failed to get scan results: {e}")
            return None
    
    async def _execute_scan(self, scan_id: str, request: ScanRequest):
        """Execute the complete vulnerability scan"""
        start_time = time.time()
        
        try:
            # Update status to running
            await self._update_scan_status(scan_id, ScanStatus.RUNNING)
            
            # Step 1: Get contract information
            logger.info(f"Getting contract info for {request.contract_address}")
            contract_info = await self._get_contract_info(request.contract_address)
            
            # Step 2: Run exploit suite analysis
            logger.info(f"Running exploit suite analysis")
            exploit_findings = await self._run_exploit_suite(request.contract_address)
            
            # Step 3: Get source code if available
            source_code = await self._get_source_code(request.contract_address)
            bytecode = await self._get_bytecode(request.contract_address)
            
            # Step 4: AI Analysis
            await self._update_scan_status(scan_id, ScanStatus.ANALYZING)
            logger.info(f"Running AI analysis")
            
            ai_vulnerabilities, ai_analysis = await self.ai_analyzer.analyze_contract(
                request.contract_address,
                source_code=source_code,
                bytecode=bytecode,
                contract_info=contract_info,
                vulnerability_context=exploit_findings
            )
            
            # Step 5: Combine and deduplicate findings
            all_vulnerabilities = self._merge_findings(exploit_findings, ai_vulnerabilities)
            
            # Step 6: Generate report
            await self._update_scan_status(scan_id, ScanStatus.GENERATING_REPORT)
            logger.info(f"Generating scan report")
            
            report_paths = await self.report_generator.generate_report(
                scan_id=scan_id,
                contract_address=request.contract_address,
                contract_info=contract_info,
                vulnerabilities=all_vulnerabilities,
                ai_analysis=ai_analysis,
                scan_config=request.__dict__
            )
            
            # Step 7: Update final results
            scan_duration = time.time() - start_time
            
            await self._update_scan_results(
                scan_id=scan_id,
                vulnerabilities=all_vulnerabilities,
                ai_analysis=ai_analysis,
                contract_info=contract_info,
                source_code=source_code,
                bytecode=bytecode,
                report_paths=report_paths,
                scan_duration=scan_duration
            )
            
            await self._update_scan_status(scan_id, ScanStatus.COMPLETED)
            logger.info(f"Scan {scan_id} completed successfully")
            
        except Exception as e:
            logger.error(f"Scan {scan_id} failed: {e}")
            await self._update_scan_status(scan_id, ScanStatus.FAILED)
            
            # Update with error information
            await self.db.execute(
                update(ScorpiusScan)
                .where(ScorpiusScan.id == scan_id)
                .values(
                    notes=f"Scan failed: {str(e)}",
                    completed_at=datetime.utcnow()
                )
            )
            await self.db.commit()
    
    async def _get_contract_info(self, address: str) -> ContractInfo:
        """Get basic contract information"""
        try:
            # Use Web3 to get basic info
            # This is a simplified version - in production you'd use actual Web3 calls
            return ContractInfo(
                address=address,
                verified=False,  # Check with Etherscan API
                proxy=False,     # Detect proxy pattern
                balance="0",     # Get actual balance
                tx_count=0       # Get transaction count
            )
        except Exception as e:
            logger.error(f"Failed to get contract info: {e}")
            return ContractInfo(address=address)
    
    async def _run_exploit_suite(self, address: str) -> List[Dict[str, Any]]:
        """Run the existing exploit suite tools"""
        findings = []
        
        try:
            # Run universal backdoor scanner
            scanner_script = self.exploit_suite_path / "scripts" / "universal_backdoor_scanner.js"
            
            if scanner_script.exists():
                logger.info("Running universal backdoor scanner")
                
                # Run the Node.js script
                result = subprocess.run(
                    ["node", str(scanner_script), address],
                    cwd=str(self.exploit_suite_path),
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode == 0:
                    # Parse the output for vulnerabilities
                    output = result.stdout
                    if "BACKDOOR FOUND" in output or "VULNERABILITY DETECTED" in output:
                        findings.append({
                            "source": "exploit_suite",
                            "tool": "universal_backdoor_scanner",
                            "output": output,
                            "severity": "critical" if "CRITICAL" in output else "high"
                        })
                
            # Run other exploit suite tools
            other_scanners = [
                "broad_vulnerability_scanner.js",
                "smart_vulnerability_scanner.js",
                "direct_exploit_scanner.js"
            ]
            
            for scanner in other_scanners:
                scanner_path = self.exploit_suite_path / "scripts" / scanner
                if scanner_path.exists():
                    try:
                        result = subprocess.run(
                            ["node", str(scanner_path), address],
                            cwd=str(self.exploit_suite_path),
                            capture_output=True,
                            text=True,
                            timeout=30
                        )
                        
                        if result.returncode == 0 and result.stdout:
                            findings.append({
                                "source": "exploit_suite",
                                "tool": scanner,
                                "output": result.stdout,
                                "severity": "medium"
                            })
                    except Exception as e:
                        logger.warning(f"Scanner {scanner} failed: {e}")
                        continue
            
        except Exception as e:
            logger.error(f"Exploit suite execution failed: {e}")
        
        return findings
    
    async def _get_source_code(self, address: str) -> Optional[str]:
        """Get contract source code from Etherscan"""
        try:
            # This would use Etherscan API in production
            # For now, return None
            return None
        except Exception as e:
            logger.error(f"Failed to get source code: {e}")
            return None
    
    async def _get_bytecode(self, address: str) -> Optional[str]:
        """Get contract bytecode"""
        try:
            # This would use Web3 in production
            # For now, return None
            return None
        except Exception as e:
            logger.error(f"Failed to get bytecode: {e}")
            return None
    
    def _merge_findings(
        self, 
        exploit_findings: List[Dict], 
        ai_findings: List[VulnerabilityFinding]
    ) -> List[VulnerabilityFinding]:
        """Merge and deduplicate findings from different sources"""
        
        merged = list(ai_findings)  # Start with AI findings
        
        # Convert exploit suite findings to VulnerabilityFinding objects
        for finding in exploit_findings:
            # Parse exploit suite output to extract vulnerability info
            output = finding.get("output", "")
            
            if "execute" in output.lower() and "backdoor" in output.lower():
                vuln = VulnerabilityFinding(
                    vuln_type="backdoor",
                    severity=VulnerabilityLevel(finding.get("severity", "medium")),
                    title="Backdoor Function Detected",
                    description=f"Exploit suite detected potential backdoor: {output[:200]}",
                    function_name="execute",
                    confidence=0.8,
                    ai_analysis=f"Found by {finding.get('tool', 'exploit_suite')}"
                )
                merged.append(vuln)
        
        return merged
    
    async def _update_scan_status(self, scan_id: str, status: ScanStatus):
        """Update scan status in database"""
        try:
            update_data = {"status": status.value}
            
            if status == ScanStatus.RUNNING:
                update_data["started_at"] = datetime.utcnow()
            elif status in [ScanStatus.COMPLETED, ScanStatus.FAILED]:
                update_data["completed_at"] = datetime.utcnow()
            
            await self.db.execute(
                update(ScorpiusScan)
                .where(ScorpiusScan.id == scan_id)
                .values(**update_data)
            )
            await self.db.commit()
            
        except Exception as e:
            logger.error(f"Failed to update scan status: {e}")
    
    async def _update_scan_results(
        self,
        scan_id: str,
        vulnerabilities: List[VulnerabilityFinding],
        ai_analysis: ScorpiusAnalysis,
        contract_info: ContractInfo,
        source_code: Optional[str],
        bytecode: Optional[str],
        report_paths: Dict[str, str],
        scan_duration: float
    ):
        """Update scan with final results and trigger autonomous exploits for high-risk contracts"""
        try:
            # Count vulnerabilities by severity
            severity_counts = {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            }
            
            for vuln in vulnerabilities:
                if vuln.severity.value in severity_counts:
                    severity_counts[vuln.severity.value] += 1
            
            # Calculate risk score based on vulnerability severity and count
            risk_score = self._calculate_risk_score(vulnerabilities, severity_counts)
            
            # Convert findings to JSON
            findings_json = [
                {
                    "vuln_type": vuln.vuln_type.value,
                    "severity": vuln.severity.value,
                    "title": vuln.title,
                    "description": vuln.description,
                    "function_name": vuln.function_name,
                    "function_signature": vuln.function_signature,
                    "line_number": vuln.line_number,
                    "code_snippet": vuln.code_snippet,
                    "exploit_code": vuln.exploit_code,
                    "mitigation": vuln.mitigation,
                    "references": vuln.references or [],
                    "confidence": vuln.confidence,
                    "ai_analysis": vuln.ai_analysis
                }
                for vuln in vulnerabilities
            ]
            
            # 🚨 AUTONOMOUS EXPLOIT TRIGGER - Execute when risk score > 60
            autonomous_exploit_results = None
            if risk_score > 60 and AUTONOMOUS_EXPLOIT_AVAILABLE:
                logger.info(f"🎯 HIGH-RISK CONTRACT DETECTED (Score: {risk_score}) - Triggering Autonomous Exploit Engine")
                
                try:
                    # Execute autonomous exploit simulation
                    autonomous_exploit_results = await autonomous_exploit_if_high_risk(contract_info.address)
                    
                    logger.info(f"🔥 Autonomous exploit simulation completed for {contract_info.address}")
                    logger.info(f"   - Attacks attempted: {autonomous_exploit_results.get('attacks_attempted', 0)}")
                    logger.info(f"   - Successful exploits: {autonomous_exploit_results.get('successful_exploits', 0)}")
                    logger.info(f"   - Critical exploits: {autonomous_exploit_results.get('critical_exploits', 0)}")
                    
                except Exception as e:
                    logger.error(f"❌ Autonomous exploit simulation failed: {e}")
                    autonomous_exploit_results = {"error": str(e), "executed": False}
            else:
                if risk_score <= 60:
                    logger.info(f"ℹ️ Risk score {risk_score} below threshold (60). Skipping autonomous exploit simulation.")
                else:
                    logger.warning("⚠️ Autonomous Exploit Engine not available for high-risk contract")
            
            # Update database with results including autonomous exploit data
            update_values = {
                "vulnerabilities_found": len(vulnerabilities),
                "critical_count": severity_counts["critical"],
                "high_count": severity_counts["high"],
                "medium_count": severity_counts["medium"],
                "low_count": severity_counts["low"],
                "risk_score": risk_score,  # Add risk score to database
                "findings": findings_json,
                "ai_analysis": ai_analysis.__dict__,
                "contract_info": contract_info.__dict__,
                "source_code": source_code,
                "bytecode": bytecode,
                "report_html_path": report_paths.get("html"),
                "report_pdf_path": report_paths.get("pdf"),
                "report_json_path": report_paths.get("json"),
                "scan_duration": scan_duration,
            }
            
            # Add autonomous exploit results if available
            if autonomous_exploit_results:
                update_values["autonomous_exploit_results"] = autonomous_exploit_results
                update_values["autonomous_exploit_executed"] = autonomous_exploit_results.get("exploit_executed", False)
            
            await self.db.execute(
                update(ScorpiusScan)
                .where(ScorpiusScan.id == scan_id)
                .values(**update_values)
            )
            await self.db.commit()
            
            logger.info(f"✅ Scan results updated for {scan_id} with risk score {risk_score}")
            
        except Exception as e:
            logger.error(f"Failed to update scan results: {e}")

    def _calculate_risk_score(self, vulnerabilities: List[VulnerabilityFinding], severity_counts: Dict[str, int]) -> int:
        """
        Calculate risk score based on vulnerability severity and count
        
        Returns:
            Risk score from 0-100
        """
        base_score = 0
        
        # Scoring weights
        severity_weights = {
            "critical": 25,  # Each critical vulnerability adds 25 points
            "high": 15,      # Each high vulnerability adds 15 points
            "medium": 8,     # Each medium vulnerability adds 8 points
            "low": 3         # Each low vulnerability adds 3 points
        }
        
        # Calculate base score from severity counts
        for severity, count in severity_counts.items():
            base_score += count * severity_weights.get(severity, 0)
        
        # Additional scoring factors
        total_vulns = len(vulnerabilities)
        
        # Bonus for multiple vulnerabilities (compound risk)
        if total_vulns >= 10:
            base_score += 15
        elif total_vulns >= 5:
            base_score += 10
        elif total_vulns >= 3:
            base_score += 5
        
        # Check for specific high-risk vulnerability patterns
        high_risk_patterns = ["backdoor", "reentrancy", "admin", "privilege", "delegatecall"]
        for vuln in vulnerabilities:
            vuln_text = f"{vuln.title} {vuln.description}".lower()
            for pattern in high_risk_patterns:
                if pattern in vuln_text:
                    base_score += 10
                    break
        
        # Cap at 100 and ensure minimum of 0
        risk_score = min(100, max(0, base_score))
        
        logger.info(f"🎯 Risk Score Calculation:")
        logger.info(f"   - Critical: {severity_counts['critical']} × 25 = {severity_counts['critical'] * 25}")
        logger.info(f"   - High: {severity_counts['high']} × 15 = {severity_counts['high'] * 15}")
        logger.info(f"   - Medium: {severity_counts['medium']} × 8 = {severity_counts['medium'] * 8}")
        logger.info(f"   - Low: {severity_counts['low']} × 3 = {severity_counts['low'] * 3}")
        logger.info(f"   - Total Vulnerabilities: {total_vulns}")
        logger.info(f"   - Final Risk Score: {risk_score}/100")
        
        return risk_score

    def _get_completed_stages(self, status: str) -> List[str]:
        """Get list of completed scan stages"""
        stages = ["Initiation", "Contract Analysis", "Exploit Suite", "AI Analysis", "Report Generation"]
        
        stage_map = {
            ScanStatus.PENDING.value: [],
            ScanStatus.RUNNING.value: ["Initiation"],
            ScanStatus.ANALYZING.value: ["Initiation", "Contract Analysis", "Exploit Suite"],
            ScanStatus.GENERATING_REPORT.value: ["Initiation", "Contract Analysis", "Exploit Suite", "AI Analysis"],
            ScanStatus.COMPLETED.value: stages,
            ScanStatus.FAILED.value: []
        }
        
        return stage_map.get(status, [])
