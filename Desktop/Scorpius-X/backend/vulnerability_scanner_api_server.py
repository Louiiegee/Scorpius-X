"""
Dedicated API server for vulnerability scanning with Slither, Mythril, and Echidna
"""

import asyncio
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import uvicorn
import sys
import os
import logging
import uuid
from datetime import datetime
import socket

# Add current directory to Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from modules.real_vulnerability_scanner import RealVulnerabilityScanner

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Vulnerability Scanner API", version="1.0.0")

# Enable CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize vulnerability scanner
logger.info("Initializing Vulnerability Scanner...")
vulnerability_scanner = RealVulnerabilityScanner()
logger.info("Vulnerability Scanner initialized successfully")

# Store scan jobs in memory (in production, use Redis or database)
scan_jobs = {}

# Request/Response Models
class VulnerabilityScanRequest(BaseModel):
    """Request model for vulnerability scanning."""
    contract_address: Optional[str] = None
    contract_source: Optional[str] = None
    tools: Dict[str, bool] = {
        "slither": True,
        "mythril": True,
        "echidna": False
    }

class VulnerabilityScanResponse(BaseModel):
    """Response model for vulnerability scan submission."""
    job_id: str
    status: str
    message: str
    estimated_duration: str

class ScanStatusResponse(BaseModel):
    """Response model for scan status."""
    job_id: str
    status: str
    progress: int
    vulnerabilities: Optional[List[Dict[str, Any]]] = None
    tools_used: Optional[List[str]] = None
    scan_summary: Optional[Dict[str, Any]] = None
    completed_at: Optional[str] = None

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "message": "Vulnerability Scanner API is running",
        "available_tools": vulnerability_scanner.engines_available
    }

async def perform_vulnerability_scan(job_id: str, request: VulnerabilityScanRequest):
    """Background task to perform vulnerability scanning."""
    try:
        # Update job status to running
        scan_jobs[job_id]["status"] = "running"
        scan_jobs[job_id]["progress"] = 0
        
        logger.info(f"Starting vulnerability scan {job_id}")
        
        # Prepare scan parameters
        enabled_tools = [tool for tool, enabled in request.tools.items() if enabled]
        
        # Update progress
        scan_jobs[job_id]["progress"] = 10
        
        # Perform actual vulnerability scan
        scan_results = await vulnerability_scanner.analyze_contract(
            contract_address=request.contract_address,
            contract_source=request.contract_source,
            analysis_types=enabled_tools
        )
        
        # Update progress
        scan_jobs[job_id]["progress"] = 80
        
        # Process and format results
        vulnerabilities = []
        for vuln in scan_results.get("vulnerabilities", []):
            vulnerabilities.append({
                "id": vuln.get("id", f"vuln_{len(vulnerabilities)}"),
                "title": vuln.get("title", "Unknown Vulnerability"),
                "severity": vuln.get("severity", "Medium"),
                "impact": vuln.get("impact", "Medium"),
                "confidence": vuln.get("confidence", "Medium"),
                "description": vuln.get("description", "No description available"),
                "location": vuln.get("location", "Unknown"),
                "tool": vuln.get("source", "unknown"),
                "remediation": vuln.get("remediation", "Review and fix the identified issue")
            })
        
        # Create scan summary
        scan_summary = {
            "total_vulnerabilities": len(vulnerabilities),
            "critical": len([v for v in vulnerabilities if v["severity"] == "Critical"]),
            "high": len([v for v in vulnerabilities if v["severity"] == "High"]),
            "medium": len([v for v in vulnerabilities if v["severity"] == "Medium"]),
            "low": len([v for v in vulnerabilities if v["severity"] == "Low"]),
            "info": len([v for v in vulnerabilities if v["severity"] == "Info"]),
            "tools_used": enabled_tools,
            "scan_duration": scan_results.get("scan_duration", "0s")
        }
        
        # Calculate risk score
        risk_score = calculate_risk_score(vulnerabilities)
        scan_summary["risk_score"] = risk_score
        
        # Update job with final results
        scan_jobs[job_id].update({
            "status": "completed",
            "progress": 100,
            "vulnerabilities": vulnerabilities,
            "tools_used": enabled_tools,
            "scan_summary": scan_summary,
            "completed_at": datetime.utcnow().isoformat()
        })
        
        logger.info(f"Vulnerability scan {job_id} completed successfully")
        
    except Exception as e:
        logger.error(f"Vulnerability scan {job_id} failed: {e}")
        scan_jobs[job_id].update({
            "status": "failed",
            "error": str(e),
            "completed_at": datetime.utcnow().isoformat()
        })

def calculate_risk_score(vulnerabilities: List[Dict[str, Any]]) -> float:
    """Calculate overall risk score based on vulnerabilities."""
    if not vulnerabilities:
        return 0.0
    
    severity_weights = {
        "Critical": 10.0,
        "High": 7.5,
        "Medium": 5.0,
        "Low": 2.5,
        "Info": 1.0
    }
    
    total_score = sum(severity_weights.get(v["severity"], 1.0) for v in vulnerabilities)
    max_possible = len(vulnerabilities) * 10.0
    
    return min(total_score / max_possible * 10.0, 10.0) if max_possible > 0 else 0.0

# Main vulnerability scan endpoint
@app.post("/api/scan/submit", response_model=VulnerabilityScanResponse)
async def submit_vulnerability_scan(request: VulnerabilityScanRequest, background_tasks: BackgroundTasks):
    """Submit a contract for vulnerability scanning."""
    
    # Validate request
    if not request.contract_address and not request.contract_source:
        raise HTTPException(status_code=400, detail="Either contract_address or contract_source must be provided")
    
    enabled_tools = [tool for tool, enabled in request.tools.items() if enabled]
    if not enabled_tools:
        raise HTTPException(status_code=400, detail="At least one analysis tool must be enabled")
    
    # Create scan job
    job_id = str(uuid.uuid4())
    scan_jobs[job_id] = {
        "job_id": job_id,
        "status": "queued",
        "progress": 0,
        "created_at": datetime.utcnow().isoformat(),
        "contract_address": request.contract_address,
        "contract_source": request.contract_source,
        "tools": request.tools
    }
    
    # Start background scan
    background_tasks.add_task(perform_vulnerability_scan, job_id, request)
    
    # Estimate duration based on enabled tools
    estimated_minutes = len(enabled_tools) * 2  # Rough estimate
    estimated_duration = f"~{estimated_minutes} minutes"
    
    logger.info(f"Vulnerability scan {job_id} queued with tools: {enabled_tools}")
    
    return VulnerabilityScanResponse(
        job_id=job_id,
        status="queued",
        message=f"Vulnerability scan queued successfully with {len(enabled_tools)} tools",
        estimated_duration=estimated_duration
    )

@app.get("/api/scan/{job_id}/status", response_model=ScanStatusResponse)
async def get_scan_status(job_id: str):
    """Get the status of a vulnerability scan."""
    if job_id not in scan_jobs:
        raise HTTPException(status_code=404, detail="Scan job not found")
    
    job = scan_jobs[job_id]
    
    return ScanStatusResponse(
        job_id=job_id,
        status=job["status"],
        progress=job["progress"],
        vulnerabilities=job.get("vulnerabilities"),
        tools_used=job.get("tools_used"),
        scan_summary=job.get("scan_summary"),
        completed_at=job.get("completed_at")
    )

@app.get("/api/scan/jobs")
async def list_scan_jobs(status: Optional[str] = None):
    """List all scan jobs, optionally filtered by status."""
    jobs = list(scan_jobs.values())
    
    if status:
        jobs = [job for job in jobs if job["status"] == status]
    
    # Sort by creation time, newest first
    jobs.sort(key=lambda x: x["created_at"], reverse=True)
    
    return {"jobs": jobs, "total": len(jobs)}

@app.delete("/api/scan/{job_id}")
async def delete_scan_job(job_id: str):
    """Delete a scan job."""
    if job_id not in scan_jobs:
        raise HTTPException(status_code=404, detail="Scan job not found")
    
    del scan_jobs[job_id]
    return {"message": "Scan job deleted successfully"}

# Tool availability endpoint
@app.get("/api/scan/tools")
async def get_available_tools():
    """Get information about available scanning tools."""
    return {
        "slither": {
            "available": vulnerability_scanner.engines_available.get('slither', False),
            "description": "Static analysis tool for Solidity smart contracts",
            "capabilities": ["Static analysis", "Control flow analysis", "Data flow analysis"]
        },
        "mythril": {
            "available": vulnerability_scanner.engines_available.get('mythril', False),
            "description": "Symbolic execution tool for Ethereum smart contracts",
            "capabilities": ["Symbolic execution", "Constraint solving", "Vulnerability detection"]
        },
        "echidna": {
            "available": False,  # Placeholder
            "description": "Property-based fuzzer for Ethereum smart contracts",
            "capabilities": ["Property-based testing", "Fuzzing", "Invariant checking"]
        }
    }

def find_available_port(start_port: int = 8004) -> int:
    """Find an available port starting from the given port."""
    for port in range(start_port, start_port + 10):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(('localhost', port))
                return port
        except OSError:
            continue
    raise RuntimeError(f"No available ports found starting from {start_port}")

if __name__ == "__main__":
    logger.info("🚀 Starting Vulnerability Scanner API Server...")
    logger.info("🔍 Security analysis tools ready")
    
    # Find available port
    port = find_available_port(8004)
    if port != 8004:
        logger.info(f"Port 8004 not available, using port {port}")
    
    uvicorn.run(
        "vulnerability_scanner_api_server:app",
        host="0.0.0.0",
        port=port,
        reload=False,
        log_level="info"
    )
